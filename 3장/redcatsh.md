### 6주차 JavaScript TIL

### 📣 주제

1. this

---

## this 란?

> 대부분의 객체지향 언어에서 this는 클래스로 생성한 인스턴스 객체를 의미한다. 클래스에서만 사용할 수 있기에 혼란의 여지가 없지만 자바스크립트에서의 this는 어디서든 사용 가능하다. 함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능이며, **this는 함수를 어떤 방식으로 호출하느냐에 따라 값이 달라진다.**

---

###  1. 전역 공간에서의 this

전역 공간에서 this는 전역 객체를 가리킨다. 전역 객체는 자바스크립트 런타임 환경에 따라 다르다.
- 브라우저 환경: `window`
- Node.js: `global`

#### 전역 공간에서의 this(브라우저 환경)
```js
console.log(this === window)  // true
```
#### 전역 공간에서의 this(Node.js 환경)
```js
console.log(this === global)  // true
```
---

✅ **자바스크립트의 모든 변수는 특정 객체의 프로퍼티로서 동작한다.** 따라서 전역 변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다.

#### 💻 예제 코드:

```js
var a = 1;
console.log(a); // 1
delete window.a; // false
console.log(a, window.a, this.a) // 1 1 1
```

```js
window.c = 3;
delete window.c; // true
console.log(c, window.c, this.c) // Uncaught ReferenceError: c is not defined
```

처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되는 반면, 전역변수로 선언한 경우에는 삭제가 되지 않는다. 이는 사용자가 의도치 않게 삭제하는 것을 방지하기 위한 나름의 방어 전략으로 해석되며, 전역변수를 선언하면 **자바스크립트 엔진이 해당 프로퍼티의 configurable 속성(변경 및 삭제 가능성)을 false로 정의**하는 것이다.

---

✅ 전역변수 선언과 전역객체의 프로퍼티 할당에서 **delete 명령**을 한다면?

#### 💻 예제 코드:

```js
var a = 1;
console.log(a); // 1
console.log(window.a); // 1
console.log(this.a) // 1
```
---

###  2. 메서드로서 호출할 때 그 메서드 내부에서의 this

> 함수를 실행하는 가장 일반적인 방법 두 가지는 함수로서 호출하는 경우와 메서드로서 호출하는 경우이다.<br/><br/> 
> **함수**: 그 자체로 독립적인 기능 수행<br/>
> **메서드**: 자신을 호출한 대상 객체에 관한 동작 수행

#### 함수로서 호출, 메서드로서 호출:

```js
var func = function (x) {
  console.log(this, x);
};
func(1);  // window { ... } 1

var obj = {
  method: func
};
obj.method(2); // { method: f } 2
```
'함수로서 호출'과 '메서드로서 호출' 구분 방법은 **함수 앞에 점(.)이 있는지 여부 판단이다. `func(1);`은 앞에 점이 없으니 함수로 호출한 것이고, `obj.method(2);`는 점이 있으니 메서드로서 호출한 것이다. 이는 대괄호 표기법에 따른 경우에도 똑같이 적용된다. (`obj['method'](2)`)

---

✅ **메서드 내부에서의 this**

> `this`에는 호출한 주체에 대한 정보가 담긴다. 어떤 함수를 메서드로서 호출하는 경우 호출 주제는 함수명(프로퍼티명) 앞의 객체이다.

---

###  3. 함수로서 호출할 떄 그 함수 내부에서의 this

✅ **함수 내부에서의 this**
> 함수로서 호출하는 것은 호출 주체를 명시하지 않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없다. 따라서 this가 지정되지 않기 때문에 함수에서의 this는 전역 객체를 가리킨다.

✅ **메서드 내부함수에서의 this**
> this 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고 해당 함수를 호출하는 구문 앞에 점 또는 대괄호 표기가 있는지 없는지가 관건이다. 

✅ **ES6에서 메서드 내부함수에서의 this를 우회하는 방법**
```js
var obj = {
  outer: function () {
    console.log(this)  // (1) { outer: f }
    var innerFunc = () => {
      console.log(this);  // (2) { outer: f }
    };
    innerFunc();
  }
};
obj.outer();
```
ES6에서는 함수 내부에서 this가 전역객체를 바라보는 문제를 보완하고자 this를 바인딩하지 않는 화살표 함수를 새로 도입했다. 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지고 상위 스코프의 this를 그대로 활용할 수 있다. 

---

###  4. 콜백 함수 호출 시 그 함수 내부에서의 this

 > 콜백 함수도 함수이기 때문에 기본적으로 this가 전역객체를 참조하지만, 콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조한다.

---

###  5. 생성자 함수 내부에서의 this

 생성자 함수는 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용되는 함수이다. 생성자란 구체적인 인스턴스를 만들기 위한 일종의 틀이다. 자바스크립트는 함수에 생성자로서의 역할을 함께 부여했다. `new` 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작한다. 

 > 1. 생성자 함수 호출  
 >2. 생성자의 prototype 프로퍼티를 참조하는 __proto__라는 프로퍼티가 있는 객체(인스턴스) 만듦
 >3. 미리 준비된 공통 속성 및 개성을 해당 객체(this)에 부여 
 >4. 구체적인 인스턴스 만들어짐

#### 💻 예제 코드:
```js
var Cat = function (name, age) {    // Cat이라는 변수에 익명 함수 할당
  this.bark = '야옹';
  this.name = name;
  this.age = age;
};
var choco = new Cat('Choco', 7);  // 생성자 함수 내부에서의 this: choco 인스턴스를 가리킴
var nabi = new Cat('Nabi', 5);    // 생성자 함수 내부에서의 this: nabi 인스턴스를 가리킴
console.log(choco, nabi);

/* 결과
Cat { bark: '야옹', name: 'Choco', age: 7}
Cat { bark: '야옹', name: 'Nabi', age: 5}
*/
```
