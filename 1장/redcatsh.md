### 2주차 JavaScript TIL

### 📣 주제

1. 데이터 타입

---

### 1-1. 데이터 타입의 종류

- 기본형(원시형, primitive type): 값 자체를 직접 저장(주솟값을 바로 복제) (숫자, 문자열, 불리언, null, undefined, symbol 등) => 불변성
- 참조형(reference type): 값이 저장된 메모리 주소를 저장하여 값을 참조 (object, Array, Function, Date, RegExp 등) => 가변성

---

### 1-2. 데이터 할당 

#### ✔️ 원시 타입 데이터 할당

![image](https://github.com/user-attachments/assets/fb94b231-5684-4110-aa85-290b2d3dc569)

원시 타입 변수가 값을 참조 해오는 데이터 영역에서는 변수의 재할당이 이루어지면 새로운 주소 영역에 데이터를 할당한다.
변수 a을 선언해 문자열 값 "abc"을 선언하고, 다시 "abcdef"로 재선언하면 값이 수정 되는 것이 아니라 데이터 영역에 "abcdef" 값을 새로 선언하고 변수 a에서는 데이터 영역에서 값을 참조해오는 주소값만 바뀐다.

**이렇게 데이터를 할당하는 이유**
==> 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위해서!

#### 💻 예제 코드:

```js
let a = 5;
let b = a;
a = 10; 
// 'b'는 여전히 5를 유지, 'a'는 10으로 변경됨
```

- 복사 방식: 원시 타입의 값을 다른 변수에 할당하면 값이 복사된다. 변수 b는 a의 값을 복사하여 자신만의 독립적인 값을 가진다.
- 메모리 할당: 원시 타입의 값은 크기가 고정되어 있으며, 스택(Stack) 메모리에 저장된다. 스택 메모리는 비교적 작고 빠른 저장 공간이다.

--------

#### ✔️ 참조 타입 데이터 할당

![image](https://github.com/user-attachments/assets/79bbd0be-8f9f-4c76-8298-33512fe09037)

데이터 영역에서는 a,b의 데이터 값을 할당하고, obj1의 변수 영역에 a,b가 데이터로써 존재하고 a,b는 데이터 영역에서 값을 참조한다.
그리고 obj1은 변수 영역 자체를 참조해 데이터을 다룬다.
객체 타입은 가변성을 띈다고 했지만, 객체 변수 내에 원시 타입 변수를 수정할 때는 불변성을 그대로 유지한다.

#### 💻 예제 코드:

```js
let obj1 = {name: 'Song'};
let obj2 = obj1; // obj1과 obj2가 같은 객체를 참조
obj1.name = 'Hee'; // obj2의 값을 변경
// 'obj2'의 name 값도 'Hee'로 변경됨
```

- 복사 방식: 참조 타입의 값을 다른 변수에 할당하면 메모리 주소가 복사된다. 즉, 두 변수는 동일한 객체를 가리킨다. 여기서 obj2는 obj와 같은 메모리 주소를 참조하므로 하나의 변수를 변경하면 다른 변수에도 영향을 준다.
- 메모리 할당: 참조 타입의 값은 크기가 동적이기 때문에 힙(Heap) 메모리에 저장된다. 힙 메모리는 크고 유연하지만 스택 메모리보다 속도가 느리다.

**🚨 이 방식의 문제점**

동일한 객체를 여러 변수가 참조할 경우, 한 변수가 객체의 값을 변경하면 다른 변수에서도 그 변경 사항이 반영된다. 이를 통해 부작용이 발생할 수 있으며, 의도하지 않은 동작을 초래할 수 있다.

---

#### ✔️ 불변 객체 만들기

#### 1. Spread 연산자(...)를 사용한 얕은 복사
얕은 복사는 객체의 최상위 속성만 복사하고, 그 속성이 참조하고 있는 **중첩된 객체나 배열에 대해서는 참조값(메모리 주소)**만 복사한다.  속성이 단순한 경우에는 얕은 복사를 통해 해결한다.

#### 💻 예제 코드:

```js
let obj1 = { name: 'Song' };
let obj2 = { ...obj1 };  // Spread 연산자를 사용한 얕은 복사
obj1.name = 'Hee';

console.log(obj1.name);  // 'Hee'
console.log(obj2.name);  // 'Song', 서로 영향을 주지 않음

```

#### 2. `JSON.parse()`와 `JSON.stringify()`를 사용한 깊은 복사
이 방법은 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 것이다.
객체 내에 중첩된 객체가 있거나, 더 복잡한 객체 구조일 때 사용된다. 이 경우 깊은 복사로 모든 속성을 복사하며, 중첩된 객체나 배열까지도 완전히 새로운 복사본을 생성한다. 이로 인해 원본 객체와 복사된 객체가 완전히 독립적이 된다. 

#### 💻 예제 코드:

```js
let obj1 = { 
    name: 'Song', 
    details: { age: 30, address: { city: 'Seoul', country: 'Korea' } } 
};

let obj2 = JSON.parse(JSON.stringify(obj1));  // 깊은 복사

// obj1의 값을 변경
obj1.name = 'Hee';
obj1.details.age = 20;
obj1.details.address.city = 'Gyeonggi';

console.log(obj1.name);  // 'Hee'
console.log(obj1.details.age);  // 30
console.log(obj1.details.address.city);  // 'Gyeonggi'

console.log(obj2.name);  // 'Song', 깊은 복사로 obj2에 영향 없음
console.log(obj2.details.age);  // 30, obj1의 변경이 obj2에 영향을 주지 않음
console.log(obj2.details.address.city);  // 'Seoul', 여전히 원래 값 유지
```

---

### 1-3. undefined와 null

`undefined`와 `null`은 JavaScript에서 "값이 없음을" 나타내는 두 가지 특수한 값이지만, 그 의미와 사용 목적은 서로 다르다.

#### undefined
- 값이 할당 되지 않은 변수 또는 존재하지 않는 속성
- 변수를 선언했으나 값이 주어지지 않았을 때 자동으로 undefined를 할당함
- 자체적으로 'undefined'라는 타입을 가짐

#### null
- 사용자가 의도적으로 값이 없음을 나타내기 위해 사용
- 자동으로 할당되지 않고 명시적으로 사용자가 할당해야 함
- 타입은 'object' 인데, 이는 JavaScript 자체 버그이다.

#### 💎 차이점 정리

| 특성                 | undefined                                                   | null                                                         |
|----------------------|-------------------------------------------------------------|--------------------------------------------------------------|
| **정의**             | 값이 할당되지 않은 상태                                      | 값이 의도적으로 없다는 의미                                   |
| **자동 할당 여부**   | 변수나 속성이 선언되었지만 값이 없으면 자동으로 할당          | 사용자가 명시적으로 할당해야 함                           |
| **유형(Type)**       | `"undefined"`                                                | `"object"` (타입 오류로 인해)                                 |
| **사용 목적**        | 변수가 초기화되지 않았거나 값이 없음을 나타냄                  | 의도적으로 값이 없다는 것을 나타냄                            |
| **비교 (==와 ===)**  | `undefined == null`은 `true` (느슨한 비교) <br> `undefined === null`은 `false` (엄격한 비교) | `null == undefined`은 `true` (느슨한 비교) <br> `null === undefined`은 `false` (엄격한 비교) |
